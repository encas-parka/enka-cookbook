{{ define "main" }}

<script src="{{ .Site.BaseURL }}flatpickr/flatpickr.js"></script>
<link rel="stylesheet" href="{{ "flatpickr/flatpickr.css" | relURL }}">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, minimal-ui"> 

<iframe id="print-iframe" width="0" height="0"></iframe>

<!-- Liste qui contiendra tous les ingrédients avec leurs données associés (quantité, recette, date, assietes...). Sert aux tableaux des quantités.  -->
{{- $IngredientList := slice -}}

<!-- Liste qui contiendra qui contient les listes de recettes pour chaque date -->
{{- $recettesList := slice -}}


{{- $IngredientsTypesList := slice -}}
{{- $recettesAll :=  dict -}}
{{$recetteKey:= 1}}

{{- range $.Param "repas" -}}
  <!-- Creation des variables qui ne seront plus visible au prochain scope. Nous sommes dans les params de l'Evenement -->
  {{- $dateService:=.date_service -}}
  {{- $horaire:=.horaire -}}
  {{- $assiettes:= (int .assiettes)  -}}
 
  <!--  -->
  {{- range .recettes_du_repas -}}
  <!-- Creation des variables qui ne seront plus visible au prochain scope. Nous sommes dans les params de 1er niveau des recettes -->
    {{- $recette:=.recette -}}
    {{- $typePlat:=.type_plat -}}
    {{ if .altAssiettes }}
      {{- $assiettes = .altAssiettes  -}}
    {{ end }}

    <!-- Envoie de la liste des recettes dans recettesList-->
    {{- $recettesList = $recettesList | append (dict 
      "recetteKey" $recetteKey 
      "recette" .recette 
      "dateService" $dateService 
      "horaire" $horaire 
      "typePlat" $typePlat 
      "assiettes" $assiettes 
      "chef" .chef 
      "commentaire" .commentaire
      "partof" .partof
      )  -}}
    {{/*  incrémentation des "id" unique des recettes  */}}
    {{$recetteKey = (add (float $recetteKey) 1)}}

    <!-- Reccupération des données sur les pages de chaque recettes -->
    {{- $url:= print .recette | urlize -}}
    {{- with site.GetPage $url -}}
      {{- $assiettesRecettes:= .Params.plate -}}
      <!-- pour tous les parametres ingredients... -->
      {{- range $key, $value := .Params.ingredients -}}
        <!-- ...on liste/boucle sur tous les sous parametres -->
        {{- range $index, $element := . -}}
        <!-- pour ingType: on reccupère la clé $key de notre range, qui correspond au nom du sous-parametre (nested parameters), et on met sa premiere lettre en majuscule -->
        {{$quantiteCompute:= float "0" }}

        {{ if .quantite }}
          {{ $quantiteCompute = ((div (mul (float .quantite) (float $assiettes )) (float $assiettesRecettes ))) }}
        {{ end }}

          {{- $IngredientList = 
              $IngredientList | append (
                dict "ingredient" .title 
                      "quantite" $quantiteCompute 
                      "unit" .unit 
                      "ingType" ($key | strings.FirstUpper ) 
                      "recette" $recette 
                      "dateService" $dateService  
                      "horaire" $horaire 
                      "typePlat" $typePlat 
                      "assiettesRecettes" $assiettesRecettes 
                      "assiettes" $assiettes
                      ) -}}
          {{- $IngredientsTypesList = $IngredientsTypesList | append (dict  "iType" ($key | strings.FirstUpper ) ) | uniq  -}}
        {{- end -}}
      {{- end -}}
     
    {{- end -}} {{/* {{ with site.GetPage $url }} */}}
  {{- end -}} {{/* recettes_du_repas */}}
{{- end -}} {{/* range $.param repas */}}



<div id="app">
{{/*  lien vers le CMS de la page  */}}
  {{ $linkCMSPage := (path.Join "/admin/#/collections/evenement/entries/" (.Title | urlize)) }}
  <span class="text-end no-print p-2"><a target="_blank" rel="noopener noreferrer" href="{{$linkCMSPage}}/index">Modifier</a></span>

 

{{/* ::: navbar page */}}
<div class="position-sticky top-0 z-9 no-print">
  <nav class="navbar navbar-expand-md navbar-light bg-light shadow py-2  rounded-bottom-4 border border-2 ">
    <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarEvent"
      aria-controls="navbarEvent" aria-expanded="false" aria-label="Toggle navigation">
      <span class="navbar-toggler-icon"></span>
    </button>
    <div class="collapse navbar-collapse" id="navbarEvent">
      <ul class="navbar-nav">
        <li class="nav-item p-1">
          <a href="#Recettes" class="btn btn-primary shadow-sm"
            :class="{ 'active': isActive === 'recettes' }">Recettes</a>
        </li>
        <li class="nav-item p-1">
          <a href="#TotalIngredients" class="btn btn-primary shadow-sm"
            :class="{ 'active': isActive === 'ingredients' }">Ingrédients</a>
        </li>
      </ul>
      <ul class="navbar-nav ms-auto">
        <li class="nav-item p-1">
          <button class="btn btn-primary shadow-sm" data-bs-toggle="modal" data-bs-target="#modalImpression"
            aria-controls="modalImpression" @click="">
            Impression / PDF
          </button>
        </li>
      </ul>
    </div>
  </nav>
</div>

{{/*  ::: Impression - MODAL  */}}
<div class="modal modal-xl fade d-print-none" tabindex="-1" id="modalImpression" aria-labelledby="modalImpressionLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class=" modal-content" >
      <div class="modal-header">
        <h5 class="modal-title fs-5" id="modalImpressionLabel">Imprimer / exporter en PDF</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">

        <div class="row">
          <div class="col">
            <div class="form-check">
              <input class="form-check-input" type="checkbox"
              v-model="toPrint.recettes"
              name="radioPrintRecettes" id="radio-printRecettes">
              <label class="form-check-label" for="radio-printRecettes">Imprimer les Recettes</label>
            </div>
            
            <div class="form-check form-switch" v-show="toPrint.recettes">
              <input
                class="form-check-input"
                type="checkbox"
                @click="selectRecettesToPrint"
                id="cb-printSelectedRecettes">
              <label class="form-check-label" for="cb-printSelectedRecettes">Selectionner les Recettes à imprimer</label>
            </div>
          </div>

          <div class="col">
            {{ range $recettesList }}
              <div class="form-check">
                <input class="form-check-input" type="checkbox"   
                v-model="togglePrintRecettes[{{.recetteKey}}]"
                id="cb-{{.recetteKey}}">
                <label class="form-check-label small" for="cb-{{.recetteKey}}">{{.recette}} </label>
              </div>
            {{ end }}
            
          </div>
        </div>

        <hr>

        <div class="form-check">
          <input class="form-check-input" type="radio" 
          v-model="toPrint.ingredients" name="radioPrintIngredients" id="radio-printIngredient">
          <label class="form-check-label" for="radio-printIngredient">Imprimer la liste de tous les ingrédients</label>
        </div>
        <div class="form-check">
          <input class="form-check-input" type="radio"
          
          name="radioPrintIngredients" id="radio-printSelectedIngredient">
          <label class="form-check-label" for="radio-printSelectedIngredient">Selectionner les listes d'ingrédients à imprimer</label>
        </div>
      
      <hr>
      <div class="text-end">
        <a class="btn btn-primary btn-sm " @click="" role="button">Imprimer !</a>
      </div>
      </div>
    </div>
  </div>
</div>


{{/* ::: _LES RECETTES   */}}
<div :class="{}">
  <h3 id="Recettes" class="no-print">Les {{len $recettesList}} recettes prévues pour l'événement "{{.Page.Title}}"</h3>
  <div class="col-3 ms-auto">
    <div class=" d-print-none p-2 ms-auto form-check form-switch">
      <input class="form-check-input" type="checkbox" role="switch" id="switchDetailDisplay" v-model="displayDetails">
      <label for="switchDetailDisplay" class="form-check-label">Afficher les détails</label>
    </div>
  </div>

  {{/* ::: _sommaire */}}
  <div :class="{'no-print' : !sectionsToPrint.includes('Recettes')}">
    <div class="no-print">
      {{/* Variable permettant de vérifier si les recettes sont de la meme date et du meme horaire ou pas; pour gérer
      leur
      affichage / l'organisation des recettes */}}
      {{ $dateService := "none"}}
      {{ $horaire := "none" }}
      <div class="card p-4 m-2">
        <span class="fs-4">Sommaire</span>
        {{- range $recettesList -}}
        <div class="">
          {{ if and (ne (.dateService | time.Format "Monday 2 January ") $dateService) }}
          <a href="#{{.dateService | time.Format "Monday 2 January" |urlize}}" class="fw-bolder">
            <slot name='{{.dateService | time.Format "Monday 2 January" | urlize}}'>{{.dateService | time.Format "Monday 2 January"}}</slot>
          </a>
          {{ end }}

          <div class="ms-5">
            <a href="#{{ .recetteKey }}">
              <slot name="{{ .recetteKey }}"></slot>{{.recette }} → ({{.horaire}} - {{.typePlat}})
            </a>
          </div>
        </div>
        {{ $dateService = (.dateService | time.Format "Monday 2 January ")}}

        {{end}}
      </div>
    </div>


{{/*  ::: __Les intertitres jours  */}}
{{ range sort $recettesList }}
{{/*  variables  */}}

<div class="no-print">
  {{ if ne (.dateService | time.Format "Monday 2 January ") $dateService }}
    <div class="h3 text-center card py-4 mx-6 bg-primary bg-opacity-10 fw-bolder"  id="{{.dateService | time.Format "Monday 2 January" |urlize}}">{{ .dateService | time.Format "Monday 2 January"}}</div>
  {{ end }}
  
  {{ if ne .horaire $horaire }}
    <div class="h4 text-center card py-3 mx-6 bg-light">{{ .horaire}} </div>
  {{ end }}
  
  {{ $dateService = (.dateService | time.Format "Monday 2 January ")}}
  {{ if eq (.dateService | time.Format "Monday 2 January ") $dateService }}
    {{ $horaire = .horaire }}
  {{ else }}
    {{ $horaire = "" }}
  {{ end }}
</div>

{{/* ::: __LES RECETTES cards */}}

{{/* TODO noprint */}}
<div 
  class="card break-after avoid-break-inside my-4 p-2 bg-light bg-opacity-25 print-enlarge"
  id="{{.recetteKey}}"
  :class="{ 'no-print': !elementsToPrint.includes('{{.recetteKey}}') && sectionsToPrint.includes('Recettes')}" 
  >
  <div class="card-body py-1 print-enlarge">
    <a class="btn btn-sm btn-outline-primary float-end no-print" 
      @click="printThis('{{.recetteKey}}')" 
    >Imprimer</a>
    <div class="py-1h2 my-2">
      <div class="my-2 h2">{{ .recette }}
        {{ with .partof }}
        <span class="ms-3 fs-5">(pour : {{ . }})</span>
        {{ end }}
      </div>
    </div>

    <div class="row">
      <div class="col">
        <div class="fw-semibold fs-5 "> {{ .dateService | time.Format "Monday 2 January "}} - {{ .horaire }} - {{
          .typePlat }}</div>
        <div class="">
          <div class="print-fs-4 print-bold">Nombre de couverts: {{ .assiettes }}</div>
          {{ if .chef }}
          <div>Référent•es: {{ .chef }} - </div>
          {{ end }}
        </div>
        <div>
          {{- $url:= print .recette | urlize -}}
          {{- with site.GetPage $url -}}
          {{ if .Params.spécialité }}
          <div class="small">Spécialité : {{ .Params.spécialité }}</div>
          {{ end }}
          {{ end }}
          {{- $url:= print .recette | urlize -}}
          {{- with site.GetPage $url -}}

        </div>

      </div>
      <div class="col text-end">
        <div class="mb-2">{{ partial "content/badge-recette.html" . }}</div>
        <div>
          {{ if .Params.materiel }}
          {{ range .Params.materiel }}
          <div class="badge bg-grey float-end me-1">{{ . }}</div>
          {{ end }}
          {{ end }}
        </div>
      </div>
      {{ end }} {{/* with site.GetPage $url */}}
    </div>
      
{{/* :::  ___LES INGREDIENTS  */}}
    <div id="IngredientsRecettes" class="row" v-show="displayDetails">
      <div class="col-md-4 print-col-30-100">
        <h5 class="text-center">Ingrédients</h5>
        
        {{/*  variable avant GetPage  */}}
        {{- $assiettes:= (int .assiettes)  -}}
        {{- $url:= print .recette | urlize -}}
        {{/*    */}}
        
        {{- with site.GetPage $url -}}

        {{/*  Reccupération de la variable .Params.plate avec le range suivant, pour pouvoir l'utiliser dans le calcul des quantités correspondant au nombre d'assiete du repas  */}}
        {{- $assiettesRecettes:= (int .Params.plate) -}}
        
        {{- range $key, $value := .Params.ingredients -}}
        {{ with . }}
        <div class="card my-2 p-2 " outlined>
          <div class="row">
            <div class="col">
              <span class="">{{ $key | strings.FirstUpper }} </span>
              
              {{ range $index, $element := . -}}
              <div class="small ps-2">
              {{/*  Pour obtenir les quantité correspondant au nombres d'assiettes indiquées  */}}
                  <span class="fw-bolder">{{ .title }}</span>
                  {{/*  TODO : alergene parial  */}}
                  {{ if .quantite }}
                    {{ if or (eq .unit "Kg") (eq .unit "litre")}}
                      : {{ $quantiteRepas := (float (div (mul (float .quantite) $assiettes ) $assiettesRecettes))}}
                      {{ if lt $quantiteRepas 1}}
                        {{ mul $quantiteRepas 1000 | math.Round }} {{/* XXX Retester */}}
                        {{ if eq .unit "litre"}}
                          {{ printf "ml" }}
                        {{ else if eq .unit "Kg"}}
                          {{ printf "gr."}}
                        {{ end }}
                      {{ else }}
                      {{ $quantiteRepas | lang.FormatNumber 2 }} {{ .unit }}
                      {{ end }}

                    {{ else }}
                      : {{ $quantiteRepas :=  (div (mul (float .quantite) $assiettes ) $assiettesRecettes)}}
                      {{ if gt $quantiteRepas 0.49 }}
                      {{ math.Round $quantiteRepas }} {{.unit}}
                      {{ else }}
                      {{ $quantiteRepas | lang.FormatNumber 2 }} {{.unit}}
                      {{ end }}
                    {{ end }}
                  {{ end }}
              </div>
              {{ end }}

            </div>
          </div>
        </div>
        {{ end }}
        {{ end }} {{/* range $key, $value := .Params.ingredients */}}
  
    
      </div>
          
      {{/*  PREPARATION  */}}
      <div class="col-md-8 print-col-70-100">
        <h5 class="text-center">Préparation</h5>
        <div class=" card card-body">
          {{ if .Params.preparation24h }}
      <div class="card border border-danger mb-4 p-3 " >
          <p class="fs-5 fw-bold text-center print-fs-medium" >A prévoir à l'avance !</p>
          <div>{{ .Params.preparation24h | markdownify }}</div>
      </div>
      {{ end }}
          {{ .Params.preparation | markdownify }}
        </div>
  
      
      </div>
          {{ range .Params.astuces }}
          <div class="col-md-5 card card-body m-2 small ">
            Astuce: {{ .astuce }}
          </div>
          {{ end }}
      {{ end }} {{/* with site.GetPage $url */}}
    </div>
  </div>
</div>
{{ end }}
    </div>

  </div>

<!--  -->
<div class="py-5 no-print" id="TotalIngredients"><hr></div>
<div class="container-fluid" >
  <div class="row justify-content-evenly">

    {{/*  ::: _Sidebar Total ingredients  */}}
    <nav class="col-md-4 col-lg-3 d-md-block bg-light sidebar mt-7">
      <div class="sticky-top" style="top: 10%">
    
        <div class="my-5">
         <div class="mb-3">
            <label class="mb-2">Selectionner la période  que vous souhaitez prendre en compte</label>
            <div class="mb-3">
              <input id="datepickerStart" class="flatpickr flatpickr-input form-control"
                type="text" readonly="readonly" placeholder="Date de début" v-model="startDateSelected"
                ></div>
            <div class="mb-3">
              <input id="datepickerEnd" class="flatpickr flatpickr-input form-control" type="text"
                readonly="readonly" placeholder="Date de fin" v-model="endDateSelected"></div>
          
              <div class="mb-3 text-end">
                <button class="btn btn-primary btn-sm shadow-sm text-white" @click="datesReset" type="button" id="btn-allDate">Toutes les dates</button>
              </div>
            </div>
            <hr>
            <div class="form-check form-switch mb-3">
              <input class="form-check-input" type="checkbox" v-model="showAllRow" id="checkRecipeDetail">
              <label for="checkRecipeDetail">Afficher les recettes pour chaque ingrédient</label>
            </div>
          </div>
        </div>
    </nav>
  
  {{/* ::: _Total INGREDIENTS   */}}
  <div class="col  print-col-12" :class="{'no-print':!sectionsToPrint.includes('Ingrédients')}">
    {{/*  TODO  */}}
    <div id="FraisByDay" class="">
  
    </div>
  
    {{ range sort $IngredientsTypesList "iType" "desc"}}
    <div v-if="this.totalsIngredientsFiltered('{{.iType}}', 'ingredients').length > 0"
      class="card my-2 mb-lg-6 avoid-break-inside  bg-tertiary">
      <div class="card-body">
        <div class="card-title h4 my-1"> Ingrédients {{ .iType }}
          <span v-if="startDate !== startDateSelected || endDate !== endDateSelected" class="fs-6 ms-2">
            - Du [[new Date (startDateSelected).toLocaleDateString("fr-FR", {weekday: 'long', month: 'long', day:
            'numeric'})]] au [[new Date (endDateSelected).toLocaleDateString("fr-FR", {weekday: 'long', month: 'long',
            day: 'numeric'})]]
          </span>
        </div>
  
  
            {{/* ::: __Table avec Details des recettes  */}}
  
            <table class="table table-bordered-bottom table-responsive" v-if="showAllRow" :class="{'no-print':!printIngredientsSimple}">
              <thead>
                <tr>
                  <th>Ingredients</th>
                  <th class="text-center">Recettes</th>
                  <th class="text-right">Total</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="item in totalsAndDetailIngredientsFiltered('{{ .iType }}', 'ingredients')"
                  :class="{'table-secondary fw-bold': item.total}"
                  >
                  <td :class="{'small text-muted': !item.total}">[[item.ingredient]]</td>
                  <td v-if="item.recette" class="small">
                    <span class="fw-bold">[[item.recette]]</span> le [[new Date(item.dateService).toLocaleDateString("fr-FR", {weekday: 'short', month: 'long', day: 'numeric'})]] -
                    [[item.horaire]] <br> pour [[item.assiettes]] couverts
                    <span class="fw-bold float-end" v-if="item.quantite && item.unit">[[item.quantite]] [[item.unit]]</span>
                  </td>
                  <td v-else></td>
                  <td class="text-right text-nowrap">
                    [[item.total]]
                    <span v-if="item.total !== 'non présisé' && item.total !== 'Incalculable ...'">[[item.unitTotal]]</span>
                    <span v-if="Array.isArray(item.fallbackTotal)">
                      <template v-for="(fallback, index) in item.fallbackTotal">
                        <span>[[fallback.quantite]] [[fallback.unit]]</span>
                        <template v-if="index !== item.fallbackTotal.length - 1">
                          <span> + </span>
                        </template>
                      </template>
                    </span>
                  </td>
                </tr>
              </tbody>
            </table>
  
            {{/* ::: __Table Sans Details des recettes */}}
            <table class="table table-bordered-bottom" v-if="!showAllRow" :class="{'no-print':!printIngredients}">
              <thead>
                <tr>
                  <th>Ingredients</th>
                  <th class="text-right">Total</th>
                </tr>
              </thead>
              <tbody>
                <tr v-for="item in totalsIngredientsFiltered('{{ .iType }}', 'ingredients')"
                  :class="{'table-secondary fw-bold': item.total && showAllRow}">
                  <template v-if="item.total">
                    <td>[[item.ingredient]]</td>
  
                  <td class="text-right  text-nowrap">
                    [[item.total]]
                    <span v-if="item.total !== 'non présisé' && item.total !== 'Incalculable ...'">[[item.unitTotal]]</span>
                    <span v-if="Array.isArray(item.fallbackTotal)">
                      <template v-for="(fallback, index) in item.fallbackTotal">
                        <span>[[fallback.quantite]] [[fallback.unit]]</span>
                        <template v-if="index !== item.fallbackTotal.length - 1">
                          <span> + </span>
                        </template>
                      </template>
                    </span>
                  </td>
                  </template>
  
                </tr>
              </tbody>
            </table>
            </div>
          </div>
        {{ end }}
  
  
  
      </div>
    </div>
</div>
</div> {{/* v-app end */}}


<script nonce="6GwL6l4yhLQddbSv2ftKfX9sTqEkpYcmwyUPm5LEdgqF6VP27IUA5SLae8ScqZ171xC7gGVVZAOuYPJnsiUAzPadx4yFkdQ7GNHa" type="module" >

  {{/*  ::: VueApp  */}}
  const app = new Vue ({
    delimiters: ['[[', ']]'],
    el: '#app',
    data () {
      return {
        search: '',
        selected: [],
        datesRepas: [], // liste des dates entre 1er et dernier repas : pour les date marqué event dans le date-picker
        startDate: null, // re-initialisé dans mounted().
        endDate: null,
        startDateSelected: null,
        endDateSelected: null, 
        endDateSelectedDebug: null,
        endDateAllowed: null,
        startDateMenu: false,
        endDateMenu: false,
        showAllRow: false,
        {{/*  ingredientsTypesList: [{{ print $IngredientsTypesList }}],  */}}
        recettes: [
        {{/* Création de la liste des recettes, et des données de chacunes, en réccupérant la liste recettesList créer par Hugo. #USELESS */}} 
          {{- range $recettesList -}}
            {
              recetteKey: "{{.recetteKey}}",
              recette: "{{ .recette }}",
              dateService: "{{ .dateService }}",
              horaire: "{{ .horaire }}",
              typePlat: "{{ .typePlat }}",
              chef: "{{ .chef }}",
              commentaire: "{{ .commentaire }}",
              assiettes: {{ .assiettes }},
          {{/* On reccupère l'url correspondant au nom de la recette... */}}
              {{- $url:= print .recette | urlize -}}
              {{- with site.GetPage $url -}}
              {{- $regime:= .Params.regime  -}}
              regime: "{{ $regime }}",
              specialite: "{{ .Params.spécialité }}",
              temperature: "{{ .Params.temperature }}",
              preparation: "{{ .Params.preparation }}",
              img: {{ .Params.img }}, 
              {{- $assiettesRecettes:= .Params.plate -}}
              assiettesRecettes: "{{ $assiettesRecettes }}",
              ingredients: [
              {
                {{- range $key, $value := .Params.ingredients -}}
                //Pour creer les parametres ingredientLofs, ingredientsSec...
                  {{ print "ingredient" ( $key | strings.FirstUpper ) }}: 
                  [
                    {{- range . }}
                    { 
                      ing: "{{ .title }}",
                      quantite: "{{ .quantite }}", //
                      unit: "{{ .unit }}",
                    },
                    {{- end }}
                  ],
                {{- end -}}
              },
              ]
              {{ end }} {{/* {{ with site.GetPage $url }} */}}
           }, // Ne pas oublier la virgule, puisqu'il s'agit d'une boucle, il y a plusieur objets dans la liste recettes
          {{ end }}
        ],

        ingredientsRecettes: [
          {{ range $IngredientList }}
          {
            ingredient: "{{ .ingredient }}",
            ingredientType: "{{ .ingType }}",
            unit: "{{ .unit }}",
            quantite: {{ .quantite }},
            recette: "{{ .recette }}",
            dateService:'{{ .dateService }}',
            horaire: "{{ .horaire }}",
            typePlat: "{{ .typePlat }}",
            assiettesRecettes: {{ .assiettesRecettes }},
            assiettes: {{ .assiettes }},
          },
          {{ end }}
          ],

              
          totalsEachIngredientHeaders: [
          { text: 'Ingrédient', value: 'ingredient' },
          { text: 'par recette', value: 'recette'},
          { text: 'Quantité totale', value: 'total', align: 'right' },
          ],

        IngredientsRepasHeaders: [
          { text: "Ingredient", value: "name", filterable: true},
          { text: "", value: "ingredient", filterable: true},
          { text: "Recette", value: "recette"},
          { text: "quantité", align: "end", filterable: false, value: "quantite" },
          ], 

        displayDetails: true,

        {{/*  ::: ___Print parameters  */}}
        sectionsToPrint: ['Recettes', "Ingrédients"],
        elementsToPrint: [],

        printRecettes: true,
        printIngredients: true,
        noprintThis: [],

        {{/*  USELESS  */}}
        printIngredientsSimple: true,
        printIngredientsDetailed: false,
        printIngredientsRowSup1: true,
        printIngredientsRowSup2: true,

        toPrint: {
          recettes: true,
          ingredients: true,
          ingredientsDetail: false,
          {{ range $recettesList }}
            {{ .recettesKey }}: true,
          {{ end }}
        },

        

        {{/*  printAffiches: false,  */}}

        printDialog: false,
          {{/*  TEST : reinclure : 'recettes'  */}}
        showedSection: ['recettes', 'ingredients'],
        isActive : null,
        IngredientsTypesList: [{{ range $IngredientsTypesList }} {{ .iType }}, {{ end }} ],
      
        ranges: [], // Tableau pour stocker les tranches de dates
        daysPerRange: 3,
        configDPStart: {
          enableTime: false,
          dateFormat: "Y-m-d",
          altInput: true,
          altFormat: "D d M",
        },


  } {{/* return */}}    
}, {{/* data */}}


{{/* ::: mounted */}}
mounted () {


  {{/*  ::: __date range  */}}
  datesRange: {
    // Trouver la première et la dernière date dans les données
    this.startDate = new Date(Math.min(
      ...this.ingredients.map(i => {
        return new Date(i.dateService);
      }),
      ),
    );
    this.endDate = new Date(Math.max(
      ...this.ingredients.map(i => {
        return new Date(i.dateService);
      }),
      ),
    );

    this.startDate = new Date(this.startDate).toISOString().substr(0, 10);
    this.endDate = new Date(this.endDate).toISOString().substr(0, 10);

    this.startDateSelected = this.startDate;
    this.endDateSelected = this.endDate
    // Derniere date autorisée dans la sélection (ne sera pas mutable puisque dans `mounted:`
    this.endDateAllowed = this.endDateSelected;


  };

  datesRepasGen: {
    // Creer un tableau avec toutes les dateService, éliminer les doublon (Set). Défini le parametre `datesRepas` de `data()`, pour mettre en evidence les dateq où il y a des évenement dans les date-picker; TODO : est-ce encore utile maintenant que les `allowed-dates` fonctionne bien ? doublon ? Ne creer pas les date intermédiare si il y a des trou =>
    const dates = this.ingredients.map(i => {
      const datesFormat = i.dateService;
      return new Date(datesFormat).toISOString().substr(0, 10) // formatage
    });

    this.datesRepas = Array.from(new Set(dates)).sort(); 
  };

  rangeDateEvents: {
    this.splitDateRanges();

  };

  endDateDebugGen: {
    /* Ajoute un jour a la endDateSelected, pour que les derniers jours soit bien pris en compte par le filtre opéré dans totalsIngredientFiltered.
    Meme fonction dans watch() pour la mise a jour en fonction de la selection dans le date-picker */
    const lastDateSelected = new Date(this.endDateSelected)
    this.endDateSelectedDebug = new Date(lastDateSelected.setDate(lastDateSelected.getDate() + 1 )).toISOString().substr(0, 10);
  };

  {{/*  ::: __flatpikr  */}}
  datePickerInit: {
    const datePicker = this.datePickerReset();
  };


}, // mounted() end

{{/*  :::Computed  */}}

computed: { 

  {{/*  #USELESS #TODO : faire le calcul en dure avec Hugo  → au moins pour le produit en croix*/}}
  ingredients: function () {
    return this.ingredientsRecettes.map(ingredient => {
      let quantite = this.computeQuantite(ingredient);
      return {
        ... ingredient,
        quantite: quantite,
      }
    });
  },


  {{/*  totalsIngredientsFrais3Days: function (){
    const totalsIngredientFiltered = totalsIngredientsFiltered(Frais)
  },  */}}


  
  


}, // computed end

{{/*  ::: watch  */}}
watch: {

  endDateSelected: function () {
    /* Ajoute un jour a la endDateSelected, pour que les derniers jours soit bien pris en compte par le filtre opéré dans totalsIngredientFiltered. 
    Meme fonction dans mounted() pour l'initialisation ! Doit etre dans watch() sinon les changement de endDateSelected ne sont pas pris en compte... */ 
    const lastDateSelected = new Date(this.endDateSelected)
    this.endDateSelectedDebug = new Date(lastDateSelected.setDate(lastDateSelected.getDate() + 1 )).toISOString().substr(0, 10);
  }


}, // watch() end

{{/*  ::: methods  */}}
methods: { 

  showSection (el) {
    this.showedSection = el ;
    this.isActive = el ;
    window.scrollTo(0, 200);
  },


  {{/*  ::: __print  */}}
  {{/*  USELESS : faire le tri  */}}
  printSection (el) {
    this.selectToPrint.push(el);
  },

  printThis(el) {
    // mettre à jour les valeurs en utilisant $nextTick pour s'assurer que les changements sont appliqués
    this.$nextTick(() => {
      this.sectionsToPrint = ["Recettes"];
      this.elementsToPrint = [el];
      this.$nextTick(() => {
        // Différez l'impression en utilisant setTimeout
          window.print();
      });
    });
  },
  printThisRM(el) {

      this.sectionsToPrint = ["Recettes"];
      this.elementsToPrint = [el];
    setTimeout(() => {
      window.print();
    }, 1000); 
  },

  selectRecettesToPrint() {
    this.toPrint.recettes=true;
    
  },

  togglePrintRecettes (id) {
    if (!this.selectToPrint.includes(id)) {
      this.selectToPrint.push(id); 
    }
    else {
      const index = this.selectToPrint.indexOf(id);
      if (index !== -1) {
        this.selectToPrint.splice(index, 1);
      }
    }
  },

  printableElements() {
    if (this.selectToPrint.includes('Recettes')) {
      this.printRecettes = true;
    } else {this.printRecettes = false}

    if (this.selectToPrint.includes('Ingrédients')) {
      this.printIngredients = true;
    } else {this.printIngredients = false}

    {{/*  if (this.selectToPrint.includes('Affiches')) {
      this.printAffiches = true;
    } else {this.printAffiches = false}  */}}
  },

  print() {
    this.printDialog = false;
    window.print();
  },

  {{/*  USELESS . C'est quoi ? Pas de reference  */}}
  updateSelectedAttribute (e) {
    let sel, i;

    sel = document.getElementById(e.target.id);
          // remove 'selected' from prior user selection
    for (i = 0; i < sel.length; i += 1) {
      sel[i].removeAttribute("selected");
    }
          // and add 'selected' to current selection
    sel[sel.selectedIndex].setAttribute("selected", "selected");
  },

  {{/*  :::__Date picker reset  */}}
  
  datesReset: function () {
    this.startDateSelected = this.startDate;
    this.endDateSelected = this.endDateAllowed;
    const datePickerReset = this.datePickerReset();
  },

  datePickerReset() {
 
    const configDPStart = {
      enableTime: false,
      dateFormat: "Y-m-d",
      altInput: true,
      altFormat: "D d M",
      defaultDate: this.startDate,
      minDate: this.startDate,
      maxDate: this.endDateAllowed,
    };
    const configDPEnd = {
      enableTime: false,
      dateFormat: "Y-m-d",
      altInput: true,
      altFormat: "D d M",
      defaultDate: this.endDateAllowed,
      minDate: this.startDate,
      maxDate: this.endDateAllowed,
    };
 
    flatpickr(datepickerStart, configDPStart);
    flatpickr(datepickerEnd, configDPEnd);   
   
  },

  computeQuantite: function (ingredient) {
   // Recalcule les quantité d'ingredients en fonctions du nombre d'assietes prévues  
    let x = (Number(ingredient.quantite));
    if (typeof ingredient.quantite != "number") {
      ingredient.quantite = '-';
    } else if (ingredient.unit == "Kg" || ingredient.unit == "litre") {
      ingredient.quantite = Math.round(x * 100) / 100;
    } else if (ingredient.unit == "grammes") {
      ingredient.quantite = Math.round(x);
      if (ingredient.quantite > 1000) {
        ingredient.unit = "Kg"
        ingredient.quantite = ingredient.quantite / 1000      
      }
    } else {
      ingredient.quantite = Math.round(x * 10) / 10;
    }
    return ingredient.quantite;
  },

  convertToKg: function (quantite, unit) {
    return quantite / 1000;
  },

  {{/*  ::: date split range   */}}
  splitDateRanges() {
      const { datesRepas, daysPerRange } = this;
      let currentRange = [];

      for (let i = 0; i < datesRepas.length; i++) {
        if (currentRange.length === 0) {
          currentRange.push(datesRepas[i]);
        } else {
          const currentDate = new Date(datesRepas[i]);
          const previousDate = new Date(currentRange[currentRange.length - 1]);

          const diffInDays = (currentDate - previousDate) / (1000 * 60 * 60 * 24);

          if (diffInDays === 1) {
            currentRange.push(datesRepas[i]);
          } else {
            // Si la différence n'est pas de 1 jour, cela signifie une nouvelle tranche
            if (currentRange.length >= daysPerRange) {
              this.ranges.push(currentRange);
            }
            currentRange = [datesRepas[i]];
          }
        }
      }

      // Ajoutez la dernière tranche s'il y a lieu
      if (currentRange.length >= daysPerRange) {
        this.ranges.push(currentRange);
      }

  },


  {{/* ::: calculs des totaux des ingredients  */}}
  filteredIngredients: function (iType, startDate, endDate) {
    // Récupérer la liste des ingrédients
    let ingredients = this.ingredients

    // Si pas de valeurs definies, alors les dates sont celles du datepicker
    var startDate = startDate === '' ? this.startDateSelected : startDate;
    var endDate = endDate === '' ? this.endDateSelected : endDate;

    // Filtrer les ingrédients selon les critères spécifiés
    const filtered = ingredients.filter(
      (i) =>
        i.ingredientType === iType &&
        i.dateService >= this.startDateSelected &&
        i.dateService <= this.endDateSelectedDebug &&
        i.ingredient.toLowerCase().includes(this.search.toLowerCase())
    );
    return filtered
  },

  totalsIngredients: function (filteredIng) {
    const totals = [];
    const listQuantite = new Map();

    filteredIng.forEach((item) => {
      // Vérifier si l'ingrédient est déjà présent dans la carte des quantités
      if (!listQuantite.has(item.ingredient)) {
        // Si non, ajouter une entrée vide pour cet ingrédient
        listQuantite.set(item.ingredient, []);
      }

      // Vérifier si une quantité avec la même unité existe déjà pour cet ingrédient
      const existingQuantity = listQuantite
        .get(item.ingredient)
        .find((quantity) => quantity.unit === item.unit);

      if (existingQuantity) {
        // Si une quantité existe déjà, additionner la quantité actuelle à celle existante
        existingQuantity.quantite += item.quantite;
      } else {
        // Sinon, ajouter une nouvelle quantité à la liste des quantités pour cet ingrédient
        listQuantite.get(item.ingredient).push({
          quantite: item.unit === 'grammes' ? this.convertToKg(item.quantite) : item.quantite,
          unit: item.unit,
        });
      }

      // Vérifier si l'ingrédient existe déjà dans les totaux
      if (!totals[item.ingredient]) {
        // Si non, initialiser les totaux pour cet ingrédient
        totals[item.ingredient] = {
          unitTotal: item.unit,
          total: 0,
        };
      }

      // Vérifier si l'unité de l'ingrédient correspond à l'unité actuelle
      if (totals[item.ingredient].unitTotal === item.unit) {
        // Si oui, additionner la quantité à la totalité de l'ingrédient
        totals[item.ingredient].total += item.quantite;
      } else if (item.unit === 'grammes' && totals[item.ingredient].unitTotal === 'Kg') {
        // Si les unités sont différentes (grammes et Kg), convertir la quantité en Kg avant de l'ajouter à la totalité
        const total = this.convertToKg(item.quantite);
        totals[item.ingredient].total += total;
        totals[item.ingredient].unitTotal = 'Kg';

      } else {
        // Si les unités ne peuvent pas s'additionner ou sont de différentes natures, ajouter la quantité à la liste des quantités alternatives
        totals[item.ingredient] = {
          total: 'Incalculable...',
        };
      }

      // Arrondir à 2 décimales
      if (typeof totals[item.ingredient].total === 'number' && totals[item.ingredient].total > 0) {
        const rounded = totals[item.ingredient].total;
        totals[item.ingredient].total = Math.round(rounded * 100) / 100;
      } else if (totals[item.ingredient].total === 'Incalculable...') {
        // Si le total est incalculable, utiliser la liste des quantités alternatives
        totals[item.ingredient] = {
          total: 'Incalculable...',
          fallbackTotal: listQuantite.get(item.ingredient).map((quantity) => ({
            quantite: Math.round(quantity.quantite * 100) / 100,
            unit: quantity.unit,
          })),
        };
      } else {
        // Si le total n'est pas un nombre valide, le définir comme "non précisé"
        totals[item.ingredient].total = 'non précisé';
      }
    });

    // Retourner les totaux des ingrédients filtrés (trié par noms d'ingredients)
    return Object.entries(totals).map(([ingredient, { unitTotal, total, fallbackTotal, ...item }]) => ({
      ingredient,
      unitTotal,
      total,
      fallbackTotal,
      ...item,
    })).sort((a, b) => a.ingredient.localeCompare(b.ingredient));
  },

 
  totalsIngredientsFiltered(iType) {
    // Appeler la première méthode pour filtrer les ingrédients
    const filtered = this.filteredIngredients(iType);

    // Appeler la deuxième méthode pour calculer les totaux à partir des ingrédients filtrés
    const totals = this.totalsIngredients(filtered);

    // Retourner les totaux
    return totals;
  },

  totalsAndDetailIngredientsFiltered(iType) {
    const total = this.totalsIngredients(this.filteredIngredients(iType));
    const element = this.filteredIngredients(iType);

    const result = new Set([...element, ...total].sort((a, b) => a.ingredient.localeCompare(b.ingredient)));

    return result;
  },





  ingredientTypeList () {
    return [...new Set (this.ingredients.map(ingredient => ingredient.ingredientType))];
  },



  filteredResultsCount(iType) {
    return this.totalsIngredientFiltered(iType, 'ingredients').length;
  },

  datesAllowedRange: function (val) {
// retourne toutes les dates comprisent entre la premiere et la dernieres =>
    for(
      var datesAllowedArray=[],
      date=new Date(this.startDate); 
      date <= new Date(this.endDateAllowed); 
      date.setDate(date.getDate()+1)){
        datesAllowedArray.push(new Date(date).toISOString().substr(0, 10));
      }

    for (var i = 0; i < datesAllowedArray.length; i++) {
      if (datesAllowedArray[i] == val ){
        return val
      };
    }
  },


} {{/* fin de methods */}}
}); {{/* fin New Vue */}}


</script>




{{ end }}
